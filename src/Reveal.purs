module Reveal where

import Prelude

import Data.Foldable (foldMap)
import Data.List

import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)

import Text.Smolder.HTML (Html)
import Text.Smolder.HTML as Html
import Text.Smolder.HTML.Attributes as Html
import Text.Smolder.Markup
import Text.Smolder.Renderer.String as Smolder

--------------------------------------------------------------------------------
-- * A mostly shallow embedding

type RevealOpts = { styles :: Array String, script :: String }

-- | A complete slideshow
data Deck = Deck (Array Section)

instance deckMonoid :: Monoid Deck where
  mempty = Deck []
  Deck a `mappend` Deck b = Deck (a <> b)

-- only one level of nesting allowed
data Section
  = Single Slide
  | Section (Array Slide)   -- ^ A subsection, with a list of vertical slides

data Slide = Slide SlidePiece

-- A slide is a rose tree
data SlidePiece
  = Node Markup
  | Columns (Array SlidePiece)
  | Rows    (Array SlidePiece)
  | Nested SlidePiece
           (Array SlidePiece)

-- TODO: Refactor this as a Typed Tagless Final embedding, then compile to
-- (a) Reveal.js
-- (b) React (i.e. https://github.com/paf31/purescript-thermite-presentation)
-- (c) Whatever you want

-- TODO: collapsing all three types into a sum type will allow for us to write a
-- Monoid instance for Slideshow, but we will lose the guarantees that this
-- hierarchy enforces (i.e. possible to have 'Deck' inside a 'Section')

-- * Combinators and slide elements

infix 5 vcat as  <==>

-- TODO: hcat is hard because you have to resize css columns and stuff, have to
-- know the entire column layout beforehand

-- infix 5 hcat as  <||>
infix 5 nest as  <%>


vcat :: SlidePiece -> SlidePiece -> SlidePiece
vcat (Columns xs) (Columns ys) =
  if length xs == length ys then Columns (zipWith

hcat :: SlidePiece -> SlidePiece -> SlidePirce
hcat =  error "TODO"

nest :: SlidePiece -> SlidePiece -> SlidePiece
nest (Element el kids attrs rest) nested = Element el (kids <> Just nested) attrs rest
nest (Content s rest) nested =
nest (Return a) nested =

t :: String -> SlidePiece
t = text

title :: String -> SlidePiece
title =  Html.h1 <<< text

subtitle :: String -> SlidePiece
subtitle = Html.h2 <<< text

data BulletStyle = Dot | Num | Alpha | RomanU | RomanL

-- This has to maintain the closure property for nesting, so no list of strings :(
bullets :: BulletStyle -> [SlidePiece] -> SlidePiece
bullets style = blType <<< foldMap Html.li
  where blType Dot    = Html.ul
        blType Num    = Html.ol
        blType Alpha  = Html.ol ! Html.type' "a"
        blType RomanU = Html.ol ! Html.type' "I"
        blType RomanL = Html.ol ! Html.type' "i"

-- bullets :: String -> Slide
-- bullets =  error "TODO"

-- -- filepath
-- image :: String -> Slide
-- image =  error "TODO"

--------------------------------------------------------------------------------
-- * Default templates

-- TODO: Include this in the 'Deck' data type? Autogenerated footers, title
-- slide, etc?
type DeckMeta =
  { title       :: String
  , subtitle    :: Maybe String
  , author      :: String
  , affiliation :: Maybe String
  , date        :: Maybe String
  , venue       :: Maybe String
  }

-- TODO: add text includes and syntax highlighting

-- | A default blank metadata struct
meta :: DeckMeta
meta =
  { title       = ""
  , subtitle    = Nothing
  , author      = ""
  , affiliation = Nothing
  , date        = Nothing
  , venue       = Nothing
  }

titleSlide :: DeckMeta -> Slide
titleSlide meta = Slide $ do
  title meta.title
 -- subtitle meta.subtitle
  author meta.author

bulletSlide :: String -> SlidePiece -> Slide
bulletSlide t bs = Slide $ title t <> bs

fullImageSlide :: FilePath -> Slide

one :: Slide -> Section
one = Single

slide :: SlidePiece -> Section
slide = Single <<< Slide

--------------------------------------------------------------------------------
-- * Compile

contain :: RevealOpts -> Html -> Html
contain opts slides = do
  Html.head $ buildStyles opts.styles
  Html.body $ slides <> script
  where
    script = (Html.script ! Html.src opts.script $ pure unit)
          <> (Html.script $ text "Reveal.initialize();")

    buildStyles = foldMap (\s -> Html.link ! (Html.rel "stylesheet" <> Html.href s))

topLevel :: Html -> Html
topLevel = (Html.div ! Html.className "reveal") <<<
             (Html.div ! Html.className "slides")

section :: Html -> Html
section = parent "section"

renderHtml :: RevealOpts -> Deck -> Html
renderHtml opts (Deck d) = contain opts $ topLevel $ foldMap renderSection d
  where
    renderSection :: Section -> Html
    renderSection (Single s) = renderSlide s
    renderSection (Section ss) = section $ foldMap renderSlide ss

    renderSlide :: Slide -> Html
    renderSlide (Slide s) = section s

renderString :: RevealOpts -> Deck -> String
renderString opts = Smolder.render <<< renderHtml opts

--------------------------------------------------------------------------------
-- * Test

sampleDeck :: Deck
sampleDeck = Deck
  [ one $ titleSlide (meta { title  = "Monoids for functional programming"
                           , author = "Matt Chan"
                           , venue  = "Awake Networks"
                           })

  , slide $ title "Example"
                    <==>
           subtitle "This is an example"

  , one $ bulletSlide "A list of things" $
            bullets [ t "Foo"
                    , t "Bar"
                    , t "Baz"
                    , t "More things"
                      <%>  bullets [ t "Herp"
                                   , t "Derp"
                                   , t "Quux"
                                   ]
                    ]
  ]

defOpts :: RevealOpts
defOpts = { styles: ["css/reveal.css", "css/theme/white.css"]
          , script: "js/reveal.js"
          }

main :: forall e. Eff (console :: CONSOLE | e) Unit
main = do
  log $ renderString defOpts sampleDeck
